import { getAllArticles, articleCategories } from '../../utils/articles';import fs from 'fs';import path from 'path';import matter from 'gray-matter';// Mock fs and path modulesjest.mock('fs', () => ({  existsSync: jest.fn(),  readdirSync: jest.fn(),  readFileSync: jest.fn(),}));jest.mock('path', () => ({  join: jest.fn((...args) => args.join('/')),  basename: jest.fn((p, ext) => p.replace(/\.[^/.]+$/, '')),}));jest.mock('gray-matter', () => jest.fn((content) => {  const lines = content.split('\n');  const data: { [key: string]: any } = {};  let inFrontMatter = false;  for (const line of lines) {    if (line.trim() === '---') {      inFrontMatter = !inFrontMatter;      continue;    }    if (inFrontMatter) {      const [key, value] = line.split(': ');      if (key && value) {        try {          data[key.trim()] = JSON.parse(value.trim());        } catch {          data[key.trim()] = value.trim();        }      }    } else if (line.startsWith('tags:')) {      data.tags = JSON.parse(line.substring(5).trim());    } else if (line.startsWith('relatedArticles:')) {      data.relatedArticles = JSON.parse(line.substring(16).trim());    }  }  return { data, content };}));describe('getAllArticles', () => {  const mockArticlesDir = '/mock/public/articles';  beforeEach(() => {    (path.join as jest.Mock).mockImplementation((...args) => args.join('/'));    (path.basename as jest.Mock).mockImplementation((p, ext) => p.replace(ext, ''));    (fs.existsSync as jest.Mock).mockReturnValue(true);    (fs.readdirSync as jest.Mock).mockReturnValue([]);    (fs.readFileSync as jest.Mock).mockReturnValue('');  });  afterEach(() => {    jest.clearAllMocks();  });  it('should return an empty array if no articles exist', () => {    const articles = getAllArticles();    expect(articles).toEqual([]);  });  it('should correctly parse and return articles from multiple categories', () => {    (fs.existsSync as jest.Mock).mockImplementation((p) => {      return p.startsWith(mockArticlesDir);    });    (fs.readdirSync as jest.Mock).mockImplementation((dirPath) => {      if (dirPath === '/mock/public/articles/services') {        return ['service-a.md', 'service-b.md'];      } else if (dirPath === '/mock/public/articles/guides') {        return ['guide-x.md'];      }      return [];    });    (fs.readFileSync as jest.Mock).mockImplementation((filePath) => {      if (filePath === '/mock/public/articles/services/service-a.md') {        return `---title: "Service A Title"description: "Service A Description"publishDate: "2023-01-01"---tags: ["tag1", "tag2"]relatedArticles: ["related1"]`;      } else if (filePath === '/mock/public/articles/services/service-b.md') {        return `---title: "Service B Title"description: "Service B Description"publishDate: "2023-01-02"---tags: ["tag3"]`;      } else if (filePath === '/mock/public/articles/guides/guide-x.md') {        return `---title: "Guide X Title"description: "Guide X Description"publishDate: "2022-12-25"---`;      }      return '';    });    const articles = getAllArticles();    expect(articles.length).toBe(3);    expect(articles[0]).toEqual({      id: 'service-b',      title: 'Service B Title',      description: 'Service B Description',      publishDate: '2023-01-02',      category: 'services',      tags: ['tag3'],      relatedArticles: [],    });    expect(articles[1]).toEqual({      id: 'service-a',      title: 'Service A Title',      description: 'Service A Description',      publishDate: '2023-01-01',      category: 'services',      tags: ['tag1', 'tag2'],      relatedArticles: ['related1'],    });    expect(articles[2]).toEqual({      id: 'guide-x',      title: 'Guide X Title',      description: 'Guide X Description',      publishDate: '2022-12-25',      category: 'guides',      tags: [],      relatedArticles: [],    });  });  it('should sort articles by publishDate in descending order', () => {    (fs.existsSync as jest.Mock).mockReturnValue(true);    (fs.readdirSync as jest.Mock).mockReturnValue(['article-old.md', 'article-new.md']);    (fs.readFileSync as jest.Mock).mockImplementation((filePath) => {      if (filePath.includes('article-old.md')) {        return `---title: "Old Article"publishDate: "2022-01-01"---`;      } else if (filePath.includes('article-new.md')) {        return `---title: "New Article"publishDate: "2023-01-01"---`;      }      return '';    });    const articles = getAllArticles();    expect(articles[0].title).toBe('New Article');    expect(articles[1].title).toBe('Old Article');  });  it('should skip non-markdown files', () => {    (fs.existsSync as jest.Mock).mockReturnValue(true);    (fs.readdirSync as jest.Mock).mockImplementation((dirPath) => {      if (dirPath === '/mock/public/articles/services') {        return ['service-a.md', 'image.png', 'data.json'];      }      return [];    });    (fs.readFileSync as jest.Mock).mockImplementation((filePath) => {      if (filePath === '/mock/public/articles/services/service-a.md') {        return `---title: "Service A Title"publishDate: "2023-01-01"---`;      }      return '';    });    const articles = getAllArticles();    expect(articles.length).toBe(1);    expect(articles[0].id).toBe('service-a');  });  it('should handle missing publishDate by using a default date', () => {    (fs.existsSync as jest.Mock).mockReturnValue(true);    (fs.readdirSync as jest.Mock).mockReturnValue(['no-date.md']);    (fs.readFileSync as jest.Mock).mockReturnValue(`---title: "No Date Article"---`);    const articles = getAllArticles();    expect(articles[0].publishDate).toBe('2025-06-23');  });  it('should handle missing title and description', () => {    (fs.existsSync as jest.Mock).mockReturnValue(true);    (fs.readdirSync as jest.Mock).mockReturnValue(['empty-meta.md']);    (fs.readFileSync as jest.Mock).mockReturnValue(`------`);    const articles = getAllArticles();    expect(articles[0].title).toBe('');    expect(articles[0].description).toBe('');  });});